<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NHL Live Podcast System</title>
    
    <!-- CSS Styles -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    
    <style>
        :root {
            --nhl-blue: #1e3a8a;
            --nhl-orange: #ea580c;
            --nhl-red: #dc2626;
            --nhl-green: #16a34a;
            --dark-bg: #1f2937;
            --darker-bg: #111827;
        }

        body {
            background: linear-gradient(135deg, var(--dark-bg) 0%, var(--darker-bg) 100%);
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
        }

        .navbar {
            background-color: var(--nhl-blue) !important;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .card {
            background: rgba(31, 41, 55, 0.95);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 12px;
            backdrop-filter: blur(10px);
        }

        .card-header {
            background: linear-gradient(90deg, var(--nhl-blue), var(--nhl-orange));
            border-radius: 12px 12px 0 0 !important;
            font-weight: 600;
        }

        .btn-primary {
            background: linear-gradient(90deg, var(--nhl-blue), var(--nhl-orange));
            border: none;
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 15px rgba(59, 130, 246, 0.4);
        }

        .btn-danger {
            background: linear-gradient(90deg, var(--nhl-red), #dc2626);
            border: none;
        }

        .btn-success {
            background: linear-gradient(90deg, var(--nhl-green), #16a34a);
            border: none;
        }

        .btn-warning {
            background: linear-gradient(90deg, #f59e0b, #d97706);
            border: none;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }

        .status-indicator.running {
            background: var(--nhl-green);
            animation: pulse 2s infinite;
        }

        .status-indicator.stopped {
            background: #6b7280;
        }

        .status-indicator.connected {
            background: var(--nhl-green);
        }

        .status-indicator.disconnected {
            background: var(--nhl-red);
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .scoreboard {
            background: linear-gradient(135deg, var(--nhl-blue), var(--nhl-orange));
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
        }

        .scoreboard::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="1" fill="white" opacity="0.1"/></svg>') repeat;
            background-size: 20px 20px;
        }

        .team-score {
            font-size: 2.5rem;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .team-name {
            font-size: 1.2rem;
            font-weight: 600;
            opacity: 0.9;
        }

        .vs-divider {
            font-size: 1.5rem;
            font-weight: bold;
            margin: 0 20px;
            color: white;
        }

        .audio-player {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .audio-player.playing {
            background: rgba(59, 130, 246, 0.2);
            border: 2px solid var(--nhl-orange);
            box-shadow: 0 0 15px rgba(234, 88, 12, 0.3);
        }

        .audio-player.playing .btn-primary {
            background: linear-gradient(90deg, var(--nhl-green), #16a34a);
        }

        #audio-list {
            max-height: 400px;
            overflow-y: auto;
            padding-right: 10px;
        }

        #audio-list::-webkit-scrollbar {
            width: 8px;
        }

        #audio-list::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }

        #audio-list::-webkit-scrollbar-thumb {
            background: var(--nhl-orange);
            border-radius: 4px;
        }

        #audio-list::-webkit-scrollbar-thumb:hover {
            background: #ea580c;
        }

        .log-container {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            max-height: 300px;
            overflow-y: auto;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .log-entry {
            margin: 3px 0;
            padding: 2px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .log-entry.error {
            color: #fca5a5;
        }

        .log-entry.warning {
            color: #fcd34d;
        }

        .log-entry.success {
            color: #86efac;
        }

        .log-entry.info {
            color: #93c5fd;
        }

        .progress-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .stat-box {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: var(--nhl-orange);
        }

        .stat-label {
            font-size: 0.9rem;
            opacity: 0.8;
            margin-top: 5px;
        }

        .control-panel {
            background: rgba(31, 41, 55, 0.8);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .game-card {
            background: rgba(59, 130, 246, 0.1);
            border: 2px solid rgba(59, 130, 246, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .game-card:hover {
            border-color: var(--nhl-orange);
            background: rgba(234, 88, 12, 0.1);
        }

        .game-card.selected {
            border-color: var(--nhl-green);
            background: rgba(22, 163, 74, 0.2);
        }

        .api-key-indicator {
            font-size: 0.8rem;
            padding: 2px 6px;
            border-radius: 4px;
            margin-left: 5px;
        }

        .api-key-indicator.configured {
            background-color: var(--nhl-green);
            color: white;
        }

        .api-key-indicator.missing {
            background-color: var(--nhl-red);
            color: white;
        }

        .settings-panel {
            background: rgba(31, 41, 55, 0.9);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }
    </style>
</head>

<body>
    <!-- Navigation -->
    <nav class="navbar navbar-dark">
        <div class="container-fluid">
                         <span class="navbar-brand mb-0 h1">
                 <i class="fas fa-hockey-puck"></i> NHL Live Podcast System
            </span>
            <div class="d-flex align-items-center">
                <span class="text-light me-3">
                    <span id="connection-status" class="status-indicator disconnected"></span>
                    Connection: <span id="connection-text">Disconnected</span>
                </span>
                <button class="btn btn-warning btn-sm" data-bs-toggle="modal" data-bs-target="#settingsModal">
                    <i class="fas fa-cog"></i> Settings
                </button>
            </div>
        </div>
    </nav>

    <div class="container-fluid mt-4">
        <div class="row">
            <!-- Left Column: Controls & Game Selection -->
            <div class="col-lg-4">
                <!-- API Configuration Status -->
                <div class="card mb-4">
                    <div class="card-header">
                        <i class="fas fa-key"></i> API Configuration
                    </div>
                    <div class="card-body">
                        <div class="mb-2">
                            Google API (Gemini & TTS): <span id="google-status" class="api-key-indicator missing">Not Configured</span>
                        </div>
                        <small class="text-muted">Configure your API key in Settings to start commentary</small>
                    </div>
                </div>

                <!-- Game Selection -->
                <div class="card mb-4">
                    <div class="card-header">
                        <i class="fas fa-gamepad"></i> Game Selection
                    </div>
                    <div class="card-body">
                        <div id="games-list">
                            <div class="text-center">
                                <div class="spinner-border text-primary" role="status">
                                        <span class="visually-hidden">Loading games...</span>
                                    </div>
                                <p class="mt-2">Loading available games...</p>
                                </div>
                            </div>
                            
                            <!-- Manual Game ID Input -->
                        <div class="mt-3">
                            <label for="manual-game-id" class="form-label">Or enter Game ID manually:</label>
                            <input type="text" class="form-control" id="manual-game-id" 
                                   placeholder="e.g., 2024030412" maxlength="10">
                            <small class="text-muted">Enter a 10-digit NHL game ID</small>
                                </div>
                            </div>
                        </div>

                <!-- Control Panel -->
                <div class="card">
                    <div class="card-header">
                        <i class="fas fa-play-circle"></i> Commentary Control
                            </div>
                    <div class="card-body">
                        <div class="mb-3">
                            <label for="duration-select" class="form-label">Duration (minutes):</label>
                            <div class="d-flex gap-2">
                                <select class="form-select" id="duration-select" style="flex: 1;">
                                    <option value="1">1 minute (test)</option>
                                    <option value="2">2 minutes</option>
                                    <option value="3">3 minutes</option>
                                    <option value="5" selected>5 minutes</option>
                                    <option value="10">10 minutes</option>
                                    <option value="15">15 minutes</option>
                                    <option value="30">30 minutes</option>
                                    <option value="60">60 minutes</option>
                                    <option value="custom">Custom</option>
                                </select>
                                <input type="number" class="form-control" id="custom-duration" 
                                       placeholder="分钟" min="1" max="120" style="width: 100px; display: none;">
                            </div>
                            <small class="form-text text-muted">最长可设置120分钟</small>
                        </div>

                        <div class="d-grid gap-2">
                            <button id="start-btn" class="btn btn-success btn-lg" disabled>
                                <i class="fas fa-play"></i> Start Commentary
                            </button>
                            <button id="stop-btn" class="btn btn-danger" style="display: none;">
                                <i class="fas fa-stop"></i> Stop Commentary
                            </button>
                        </div>

                        <div id="selected-game-info" class="mt-3" style="display: none;">
                            <h6>Selected Game:</h6>
                            <p id="selected-game-text" class="text-info"></p>
                        </div>
                        </div>
                    </div>
                </div>

            <!-- Middle Column: Scoreboard & Stats -->
            <div class="col-lg-4">
                <!-- Scoreboard -->
                <div class="scoreboard">
                    <div class="d-flex justify-content-center align-items-center">
                        <div class="text-center">
                            <div class="team-name" id="away-team">Away</div>
                            <div class="team-score" id="away-score">0</div>
                    </div>
                        <div class="vs-divider">VS</div>
                        <div class="text-center">
                            <div class="team-name" id="home-team">Home</div>
                            <div class="team-score" id="home-score">0</div>
                        </div>
                    </div>
                    <div class="mt-2">
                        <span id="game-status" class="status-indicator stopped"></span>
                        <span id="game-status-text">Ready</span>
                    </div>
                </div>

                <!-- Statistics -->
                        <div class="progress-stats">
                            <div class="stat-box">
                                <div class="stat-value" id="processed-files">0</div>
                        <div class="stat-label">Processed Files</div>
                            </div>
                            <div class="stat-box">
                                <div class="stat-value" id="audio-files">0</div>
                                <div class="stat-label">Audio Files</div>
                            </div>
                            <div class="stat-box">
                        <div class="stat-value" id="runtime">0:00</div>
                                <div class="stat-label">Runtime</div>
                </div>
            </div>

                                <!-- Audio Player -->
                <div class="card">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <span><i class="fas fa-volume-up"></i> Audio Commentary</span>
                        <button id="auto-play-btn" class="btn btn-outline-light btn-sm">
                            <i class="fas fa-play"></i> Auto-Play OFF
                        </button>
                    </div>
                    <div class="card-body">
                        <div id="audio-list">
                            <p class="text-muted text-center">No audio files generated yet</p>
                        </div>
                    </div>
                </div>
                </div>

            <!-- Right Column: Logs -->
            <div class="col-lg-4">
                <div class="card">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <span><i class="fas fa-terminal"></i> Pipeline Logs</span>
                        <button id="clear-logs-btn" class="btn btn-sm btn-outline-light">
                            <i class="fas fa-trash"></i> Clear
                        </button>
                    </div>
                    <div class="card-body p-0">
                        <div id="logs-container" class="log-container">
                            <div class="log-entry">System ready. Configure API keys and select a game to start.</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

    <!-- Settings Modal -->
    <div class="modal fade" id="settingsModal" tabindex="-1" aria-labelledby="settingsModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content bg-dark text-light">
                <div class="modal-header">
                    <h5 class="modal-title" id="settingsModalLabel">
                        <i class="fas fa-cog"></i> API Configuration
                    </h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="alert alert-info">
                        <i class="fas fa-info-circle"></i>
                        Configure your Google API key to enable live commentary generation. This key is stored securely in your session and is used for both AI commentary generation and speech synthesis.
                    </div>

                    <form id="api-keys-form">
                        <div class="mb-3">
                            <label for="google-api-key" class="form-label">
                                <i class="fas fa-key"></i> Google API Key (Gemini & TTS)
                            </label>
                            <input type="password" class="form-control" id="google-api-key" 
                                   placeholder="Enter your Google API key">
                            <div class="form-text">
                                This key is used for both Gemini AI commentary generation and Google Cloud Text-to-Speech. Get your key from
                                <a href="https://aistudio.google.com/app/apikey" target="_blank" class="text-info">Google AI Studio</a>
                            </div>
                        </div>
                        
                        <div class="alert alert-warning">
                            <i class="fas fa-lightbulb"></i>
                            <strong>Tip:</strong> One Google API key can be used for both Gemini AI and Text-to-Speech services. Make sure to enable the corresponding API services in Google Cloud Console.
                        </div>
                    </form>
                    
                    <div class="alert alert-warning">
                        <i class="fas fa-shield-alt"></i>
                        <strong>Security Note:</strong> Your API keys are only stored temporarily in your browser session and are never saved permanently or shared.
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="save-api-keys">
                        <i class="fas fa-save"></i> Save Configuration
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Welcome Modal for First Time Users -->
    <div class="modal fade" id="welcomeModal" tabindex="-1" aria-labelledby="welcomeModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content bg-dark text-light">
                <div class="modal-header">
                    <h5 class="modal-title" id="welcomeModalLabel">
                        <i class="fas fa-hockey-puck"></i> Welcome to NHL Live Podcast System
                    </h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="alert alert-warning">
                        <i class="fas fa-exclamation-triangle"></i>
                        <strong>Important Notice:</strong> Due to Gemini TTS usage limits, our shared quota has been exhausted. You'll need to provide your own Google API key to use this system.
                    </div>
                    
                    <div class="alert alert-info">
                        <i class="fas fa-info-circle"></i>
                        <strong>Getting Started:</strong>
                        <ol class="mt-2 mb-0">
                            <li>Click the <strong>"Settings"</strong> button in the top-right corner</li>
                            <li>Enter your Google API key (works for both Gemini AI and TTS)</li>
                            <li>Select a game or enter a Game ID manually</li>
                            <li><strong>Recommended:</strong> Start with <strong>1 minute</strong> duration for testing to avoid consuming your TTS quota</li>
                        </ol>
                    </div>
                    
                    <div class="alert alert-success">
                        <i class="fas fa-lightbulb"></i>
                        <strong>Pro Tips:</strong>
                        <ul class="mt-2 mb-0">
                            <li>Get your API key from <a href="https://aistudio.google.com/app/apikey" target="_blank" class="text-info">Google AI Studio</a></li>
                            <li>Enable both Gemini API and Text-to-Speech API in your Google Cloud Console</li>
                            <li>Use the auto-play feature to enjoy continuous commentary</li>
                            <li>Monitor your API usage to avoid unexpected charges</li>
                        </ul>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Got it!</button>
                    <button type="button" class="btn btn-primary" data-bs-dismiss="modal" onclick="openSettings()">
                        <i class="fas fa-cog"></i> Configure API Key
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script>
        // Fallback for Socket.IO if CDN fails
        if (typeof io === 'undefined') {
            document.write('<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"><\/script>');
        }
    </script>
    
    <script>
        // Global state
        let socket;
        let selectedGameId = null;
        let isRunning = false;
        let statusUpdateInterval;

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            initializeSocketIO();
            loadAvailableGames();
            loadAPIKeyStatus();
            setupEventListeners();
            startStatusUpdates();
            
            // Add global click listener to detect user interaction
            document.addEventListener('click', function() {
                if (!window.userHasInteracted) {
                    window.userHasInteracted = true;
                    console.log(`👆 User interaction detected via click`);
                }
            }, { once: true }); // Only need to detect once
        });

        function initializeSocketIO() {
            // Check if Socket.IO is available
            if (typeof io === 'undefined') {
                console.error('Socket.IO library not loaded');
                addLog('Socket.IO library failed to load. Real-time features disabled.', 'error');
                updateConnectionStatus(false);
                return;
            }
            
            try {
            socket = io();
            
            socket.on('connect', function() {
                updateConnectionStatus(true);
                addLog('Connected to server', 'success');
                loadAvailableGames();
                loadAPIKeyStatus();
                
                // Show welcome modal for first-time users
                if (!sessionStorage.getItem('nhl_system_visited')) {
                    setTimeout(() => {
                        const welcomeModal = new bootstrap.Modal(document.getElementById('welcomeModal'));
                        welcomeModal.show();
                        sessionStorage.setItem('nhl_system_visited', 'true');
                    }, 1000);
                }
            });
            } catch (error) {
                console.error('Error initializing Socket.IO:', error);
                addLog('Error connecting to server: ' + error.message, 'error');
                updateConnectionStatus(false);
            }

            socket.on('disconnect', function() {
                updateConnectionStatus(false);
                addLog('Disconnected from server', 'error');
            });

            socket.on('commentary_started', function(data) {
                addLog(`Commentary started for game ${data.game_id}`, 'success');
                updateUIForRunning(true);
            });

            socket.on('commentary_stopped', function(data) {
                addLog(`Commentary stopped for game ${data.game_id}`, 'info');
                updateUIForRunning(false);
            });

            socket.on('pipeline_log', function(data) {
                addLog(data.message, data.level, data.timestamp);
            });

            socket.on('pipeline_completed', function(data) {
                addLog(`Pipeline completed successfully for game ${data.game_id}`, 'success');
                updateUIForRunning(false);
            });

            socket.on('pipeline_error', function(data) {
                addLog(`Pipeline error: ${data.error || 'Unknown error'}`, 'error');
                updateUIForRunning(false);
            });

            socket.on('progress_update', function(data) {
                updateProgressStats(data);
            });
        }

        function setupEventListeners() {
            document.getElementById('start-btn').addEventListener('click', startCommentary);
            document.getElementById('stop-btn').addEventListener('click', stopCommentary);
            document.getElementById('clear-logs-btn').addEventListener('click', clearLogs);
            document.getElementById('save-api-keys').addEventListener('click', saveAPIKeys);
            document.getElementById('manual-game-id').addEventListener('input', handleManualGameId);
            
            // Setup duration selector
            document.getElementById('duration-select').addEventListener('change', handleDurationChange);
            
            // Setup auto-play button with click debouncing
            const autoPlayBtn = document.getElementById('auto-play-btn');
            autoPlayBtn.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                toggleAutoPlay();
            });
        }

        function handleDurationChange() {
            const durationSelect = document.getElementById('duration-select');
            const customDuration = document.getElementById('custom-duration');
            
            if (durationSelect.value === 'custom') {
                customDuration.style.display = 'block';
                customDuration.focus();
            } else {
                customDuration.style.display = 'none';
                customDuration.value = '';
            }
        }

        function updateAudioHighlighting(playingIndex) {
            // Remove all existing highlighting
            const allAudioPlayers = document.querySelectorAll('.audio-player');
            allAudioPlayers.forEach(player => player.classList.remove('playing'));
            
            // Add highlighting to currently playing audio
            if (playingIndex >= 0) {
                const playingPlayer = document.querySelector(`.audio-player[data-index="${playingIndex}"]`);
                if (playingPlayer) {
                    playingPlayer.classList.add('playing');
                }
            }
        }

        function openSettings() {
            const settingsModal = new bootstrap.Modal(document.getElementById('settingsModal'));
            settingsModal.show();
        }

        function loadAvailableGames() {
            fetch('/api/games/available')
                .then(response => response.json())
                .then(data => {
                    console.log('Games API response:', data);
                    displayGames(data.games || []);
                })
                .catch(error => {
                    console.error('Error loading games:', error);
                    addLog('Error loading available games: ' + error.message, 'error');
                    // Display error message in games list
                    const gamesList = document.getElementById('games-list');
                    gamesList.innerHTML = `
                        <div class="text-center text-danger">
                            <i class="fas fa-exclamation-triangle fa-2x mb-2"></i>
                            <p>Error loading games: ${error.message}</p>
                            <small>Check console for details</small>
                        </div>
                    `;
                });
        }

        function displayGames(games) {
            const gamesList = document.getElementById('games-list');
            
            if (!games || games.length === 0) {
                gamesList.innerHTML = `
                    <div class="text-center text-muted">
                        <i class="fas fa-hockey-puck fa-2x mb-2"></i>
                        <p>No games found. Use manual input below.</p>
                    </div>
                `;
                return;
            }

            gamesList.innerHTML = games.map(game => `
                <div class="game-card" data-game-id="${game.game_id}">
                    <div class="d-flex justify-content-between align-items-center">
                        <div>
                            <strong>${game.teams.away_team} vs ${game.teams.home_team}</strong>
                            <br>
                            <small class="text-muted">Game ID: ${game.game_id}</small>
                        </div>
                        <div class="text-end">
                            <div class="badge bg-primary">${game.timestamp_files} files</div>
                            <br>
                            <small class="text-muted">${new Date(game.last_modified * 1000).toLocaleString()}</small>
                        </div>
                    </div>
                </div>
            `).join('');

            // Add click listeners to game cards
            document.querySelectorAll('.game-card').forEach(card => {
                card.addEventListener('click', function() {
                    selectGame(this.dataset.gameId, this);
                });
            });
        }

        function handleManualGameId() {
            const input = document.getElementById('manual-game-id');
            const gameId = input.value.trim();
            
            if (gameId.length === 10 && /^\d+$/.test(gameId)) {
                selectGame(gameId, null);
            } else if (gameId.length === 0) {
                selectedGameId = null;
                updateSelectedGameDisplay();
            }
        }

        function selectGame(gameId, cardElement) {
                    selectedGameId = gameId;
            
            // Update visual selection
            document.querySelectorAll('.game-card').forEach(card => {
                card.classList.remove('selected');
            });
            
            if (cardElement) {
                cardElement.classList.add('selected');
                document.getElementById('manual-game-id').value = '';
            }
            
            updateSelectedGameDisplay();
            checkStartButtonState();
        }

        function updateSelectedGameDisplay() {
            const infoDiv = document.getElementById('selected-game-info');
            const textSpan = document.getElementById('selected-game-text');
            
            if (selectedGameId) {
                textSpan.textContent = `Game ID: ${selectedGameId}`;
                infoDiv.style.display = 'block';
            } else {
                infoDiv.style.display = 'none';
            }
        }

        function loadAPIKeyStatus() {
            fetch('/api/config/keys')
                .then(response => response.json())
                .then(data => {
                    updateAPIKeyStatus(data);
                    checkStartButtonState();
                })
                .catch(error => {
                    console.error('Error loading API key status:', error);
                });
        }

        function updateAPIKeyStatus(status) {
            const googleStatus = document.getElementById('google-status');
            
            if (googleStatus) {
                // Since we use the same key for both services, check if either is configured
                const isConfigured = status.google_configured || status.gemini_configured;
                googleStatus.className = `api-key-indicator ${isConfigured ? 'configured' : 'missing'}`;
                googleStatus.textContent = isConfigured ? 'Configured' : 'Not Configured';
            }
        }

        function saveAPIKeys() {
            const googleKey = document.getElementById('google-api-key').value.trim();
            
            if (!googleKey) {
                alert('请输入Google API密钥');
                return;
            }
            
            fetch('/api/config/keys', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    gemini_api_key: googleKey,  // Use same key for both
                    google_api_key: googleKey
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    addLog('✅ Google API密钥配置成功 (Gemini AI + TTS)', 'success');
                    updateAPIKeyStatus(data);
                    checkStartButtonState();
                    
                    // Clear form and close modal
                    document.getElementById('api-keys-form').reset();
                    bootstrap.Modal.getInstance(document.getElementById('settingsModal')).hide();
                } else {
                    alert('Error: ' + data.error);
                }
            })
            .catch(error => {
                console.error('Error saving API keys:', error);
                alert('Error saving API keys');
            });
        }

        function checkStartButtonState() {
            const startBtn = document.getElementById('start-btn');
            const hasGameId = selectedGameId && selectedGameId.length === 10;
            
            // Check API key status
            fetch('/api/config/keys')
                .then(response => response.json())
                .then(data => {
                    console.log('API keys status:', data);
                    const hasAPIKeys = data.gemini_configured && data.google_configured;
                    startBtn.disabled = !hasGameId || !hasAPIKeys || isRunning;
                    
                    if (!hasAPIKeys) {
                        startBtn.title = '请先在设置中配置API密钥';
                        if (!data.gemini_configured || !data.google_configured) {
                            addLog('⚠️ 请配置Google API密钥 (用于Gemini AI和TTS服务)', 'warning');
                        }
                    } else if (!hasGameId) {
                        startBtn.title = 'Select a game first';
                    } else if (isRunning) {
                        startBtn.title = 'Commentary is currently running';
                } else {
                        startBtn.title = '';
                    }
                })
                .catch(error => {
                    console.error('Error checking API keys:', error);
                    startBtn.disabled = true;
                    startBtn.title = 'Error checking API key status';
                });
        }

        function startCommentary() {
            if (!selectedGameId) {
                alert('Please select a game first');
                return;
            }

            let duration;
            const durationSelect = document.getElementById('duration-select');
            const customDuration = document.getElementById('custom-duration');
            
            if (durationSelect.value === 'custom') {
                duration = parseInt(customDuration.value);
                if (!duration || duration < 1 || duration > 120) {
                    alert('请输入1-120之间的有效分钟数');
                    return;
                }
            } else {
                duration = parseInt(durationSelect.value);
            }
            
            fetch('/api/commentary/start', {
                    method: 'POST',
                    headers: {
                    'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        game_id: selectedGameId,
                    duration: duration
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'started') {
                    addLog(`Starting commentary for game ${selectedGameId}`, 'info');
                    updateUIForRunning(true);
                } else {
                    alert('Error: ' + data.error);
                }
            })
            .catch(error => {
                console.error('Error starting commentary:', error);
                alert('Error starting commentary');
            });
        }

        function stopCommentary() {
            fetch('/api/commentary/stop', {
                    method: 'POST'
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'stopped') {
                    addLog('Commentary stopped', 'info');
                    updateUIForRunning(false);
                } else {
                    alert('Error: ' + data.error);
                }
            })
            .catch(error => {
                console.error('Error stopping commentary:', error);
                alert('Error stopping commentary');
            });
        }

        function updateUIForRunning(running) {
            isRunning = running;
            
            const startBtn = document.getElementById('start-btn');
            const stopBtn = document.getElementById('stop-btn');
            const gameStatusIndicator = document.getElementById('game-status');
            const gameStatusText = document.getElementById('game-status-text');
            
            if (running) {
                startBtn.style.display = 'none';
                stopBtn.style.display = 'block';
                gameStatusIndicator.className = 'status-indicator running';
                gameStatusText.textContent = 'Running';
                } else {
                startBtn.style.display = 'block';
                stopBtn.style.display = 'none';
                gameStatusIndicator.className = 'status-indicator stopped';
                gameStatusText.textContent = 'Ready';
                }
            
            checkStartButtonState();
        }

        function updateConnectionStatus(connected) {
            const indicator = document.getElementById('connection-status');
            const text = document.getElementById('connection-text');
            
            if (connected) {
                indicator.className = 'status-indicator connected';
                text.textContent = 'Connected';
            } else {
                indicator.className = 'status-indicator disconnected';
                text.textContent = 'Disconnected';
            }
        }

        function addLog(message, level = 'info', timestamp = null) {
            const container = document.getElementById('logs-container');
            const entry = document.createElement('div');
            entry.className = `log-entry ${level}`;
            
            const time = timestamp ? new Date(timestamp).toLocaleTimeString() : new Date().toLocaleTimeString();
            entry.innerHTML = `<span style="opacity: 0.7;">[${time}]</span> ${message}`;
            
            container.appendChild(entry);
            container.scrollTop = container.scrollHeight;
        }

        function clearLogs() {
            document.getElementById('logs-container').innerHTML = '';
            addLog('Logs cleared', 'info');
        }

        function updateProgressStats(data) {
            document.getElementById('processed-files').textContent = data.processed_files || 0;
            document.getElementById('audio-files').textContent = data.total_audio_files || 0;
            
            const runtime = data.runtime_seconds || 0;
            const minutes = Math.floor(runtime / 60);
            const seconds = runtime % 60;
            document.getElementById('runtime').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            // Update scoreboard
            if (data.current_score) {
                const scores = data.current_score.split('-');
                if (scores.length === 2) {
                    document.getElementById('away-score').textContent = scores[0];
                    document.getElementById('home-score').textContent = scores[1];
                }
            }
            
            if (data.game_teams) {
                document.getElementById('away-team').textContent = data.game_teams.away || 'Away';
                document.getElementById('home-team').textContent = data.game_teams.home || 'Home';
            }
        }

                function startStatusUpdates() {
            statusUpdateInterval = setInterval(() => {
                if (isRunning) {
                    fetch('/api/commentary/status')
                        .then(response => response.json())
                        .then(data => {
                            if (data.is_running) {
                                updateProgressStats(data);
                                
                                // Only check for new audio files if:
                                // 1. No audio is currently playing, OR
                                // 2. Auto-play is disabled, OR
                                // 3. It's been more than 10 seconds since last check
                                const currentlyPlaying = document.querySelector('#audio-list audio:not([paused])');
                                const now = Date.now();
                                const timeSinceLastCheck = now - (lastAudioCheckTime || 0);
                                
                                if (!currentlyPlaying || !autoPlayEnabled || timeSinceLastCheck > 10000) {
                                    loadAudioFiles();
                                    lastAudioCheckTime = now;
                                } else {
                                    console.log('Skipping audio file check to avoid interrupting playback');
                                }
                            }
                        })
                        .catch(error => {
                            console.error('Error fetching status:', error);
                        });
                }
            }, 5000);  // Check every 5 seconds
        }

        function loadAudioFiles() {
            if (!selectedGameId) return;
            
                fetch(`/api/audio/${selectedGameId}`)
                    .then(response => response.json())
                    .then(data => {
                    displayAudioFiles(data.audio_files || []);
                    })
                    .catch(error => {
                    console.error('Error loading audio files:', error);
                });
        }

                // Global state for audio management
        let currentPlayingIndex = -1;
        let autoPlayEnabled = false;
        let lastAudioCount = 0;
        let playQueue = [];
        let isPlayingFromQueue = false;
        let lastAudioCheckTime = 0;
        
        // User interaction tracking for auto-play
        window.userHasInteracted = false;

        function displayAudioFiles(files) {
            const audioList = document.getElementById('audio-list');
            
            if (files.length === 0) {
                audioList.innerHTML = '<p class="text-muted text-center">No audio files generated yet</p>';
                return;
            }
            
            // Check if we have new files (more files than before)
            const hasNewFiles = files.length > lastAudioCount;
            
            // Check for fallback audio files (TTS quota exceeded)
            const fallbackFiles = files.filter(file => file.filename.startsWith('nhl_fallback'));
            if (fallbackFiles.length > 0 && hasNewFiles) {
                addLog(`⚠️ 检测到 ${fallbackFiles.length} 个模拟音频文件 - TTS服务额度可能已用完`, 'warning');
            }
            
            // If no new files and not first load, don't update the DOM
            if (!hasNewFiles && lastAudioCount > 0) {
                console.log('No new files, skipping DOM update to preserve playback');
                return;
            }
            
            // Get currently playing audio element before update
            const currentlyPlaying = audioList.querySelector('audio:not([paused])');
            let currentTime = 0;
            let currentSrc = null;
            let wasPlaying = false;
            let currentIndex = -1;
            
            if (currentlyPlaying && !currentlyPlaying.paused) {
                currentTime = currentlyPlaying.currentTime;
                currentSrc = currentlyPlaying.src;
                wasPlaying = true;
                currentIndex = parseInt(currentlyPlaying.getAttribute('data-index')) || -1;
                console.log(`Saving playback state: index=${currentIndex}, time=${currentTime}, src=${currentSrc}`);
            }
            
            console.log(`Updating audio list: ${lastAudioCount} -> ${files.length} files`);
            
            // Create HTML for all files
            audioList.innerHTML = files.map((file, index) => `
                <div class="audio-player" data-index="${index}">
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <small class="text-muted">${file.filename}</small>
                        <small class="text-muted">${(file.size / 1024).toFixed(1)} KB</small>
                        <button class="btn btn-sm btn-primary" onclick="playAudio(${index})" style="font-size: 0.7rem;">
                            <i class="fas fa-play"></i> Play
                        </button>
                    </div>
                    <audio controls class="w-100" preload="metadata" data-index="${index}">
                        <source src="${file.url}" type="audio/wav">
                        Your browser does not support the audio element.
                    </audio>
                    ${file.transcript ? `<small class="text-muted mt-1 d-block">${file.transcript}</small>` : ''}
                </div>
            `).join('');
            
            // Setup audio event listeners for auto-play
            setupAudioEventListeners();
            
            // Restore playing state if audio was playing
            if (wasPlaying && currentSrc && currentIndex >= 0) {
                setTimeout(() => {
                    const restoredAudio = audioList.querySelector(`audio[data-index="${currentIndex}"]`);
                    if (restoredAudio && restoredAudio.src === currentSrc) {
                        console.log(`🔄 Restoring playback: index=${currentIndex}, time=${currentTime}`);
                        restoredAudio.currentTime = currentTime;
                        
                        // Mark that we have user interaction since audio was playing
                        window.userHasInteracted = true;
                        
                        restoredAudio.play().then(() => {
                            console.log('✅ Successfully restored playback');
                            currentPlayingIndex = currentIndex;
                        }).catch(error => {
                            console.error('❌ Error restoring playback:', error);
                        });
                    } else {
                        console.warn(`⚠️ Could not find audio to restore: index=${currentIndex}, src=${currentSrc}`);
                    }
                }, 100); // Small delay to ensure DOM is ready
            }
            
            // Handle auto-play for new files
            if (autoPlayEnabled && hasNewFiles) {
                console.log(`Auto-play enabled: adding new files to queue`);
                addNewFilesToQueue(lastAudioCount, files.length);
                
                // Only start auto-play queue if nothing is currently playing
                if (!wasPlaying && !isPlayingFromQueue) {
                    setTimeout(() => processAutoPlayQueue(), 200);
                }
            }
            
            lastAudioCount = files.length;
        }

        function addNewFilesToQueue(fromIndex, toIndex) {
            for (let i = fromIndex; i < toIndex; i++) {
                if (!playQueue.includes(i)) {
                    playQueue.push(i);
                    console.log(`Added audio ${i} to auto-play queue`);
                }
            }
        }

        function processAutoPlayQueue() {
            console.log(`🔄 processAutoPlayQueue called - autoPlayEnabled: ${autoPlayEnabled}, queue length: ${playQueue.length}, userInteracted: ${window.userHasInteracted}`);
            
            if (!autoPlayEnabled) {
                console.log('🛑 Auto-play disabled, clearing queue');
                playQueue = [];
                isPlayingFromQueue = false;
                return;
            }
            
            if (playQueue.length === 0) {
                console.log('📭 Auto-play queue empty');
                isPlayingFromQueue = false;
                return;
            }
            
            // Check if user has interacted with audio (required for auto-play)
            if (!window.userHasInteracted) {
                console.log('👆 Auto-play requires user interaction first. Please manually play an audio file.');
                addLog('🎵 请先手动播放一个音频以启用自动播放功能', 'info');
                isPlayingFromQueue = false;
                return;
            }
            
            // More reliable check for playing audio
            const audioElements = document.querySelectorAll('#audio-list audio');
            let actuallyPlaying = false;
            
            audioElements.forEach((audio, index) => {
                if (!audio.paused && !audio.ended && audio.currentTime > 0) {
                    console.log(`🎵 Audio ${index} is actually playing (paused: ${audio.paused}, ended: ${audio.ended}, currentTime: ${audio.currentTime})`);
                    actuallyPlaying = true;
                }
            });
            
            if (actuallyPlaying) {
                console.log('⏸️ Audio currently playing, waiting for it to finish');
                return;
            }
            
            const nextIndex = playQueue.shift();
            console.log(`🎵 Auto-playing audio ${nextIndex} from queue. Remaining in queue: ${playQueue.length}`);
            
            isPlayingFromQueue = true;
            
            // Verify the audio element exists before trying to play
            console.log(`📊 Available audio elements: ${audioElements.length}, trying to play index: ${nextIndex}`);
            
            if (nextIndex >= 0 && nextIndex < audioElements.length) {
                playAudio(nextIndex);
            } else {
                console.warn(`⚠️ Audio index ${nextIndex} is out of range, skipping`);
                isPlayingFromQueue = false;
                // Try next in queue if available
                if (playQueue.length > 0) {
                    console.log('⏭️ Trying next item in queue');
                    setTimeout(() => processAutoPlayQueue(), 100);
                }
            }
        }
        
        function setupAudioEventListeners() {
            const audioElements = document.querySelectorAll('#audio-list audio');
            audioElements.forEach((audio, index) => {
                // Check if this audio already has our custom event listeners
                if (audio.hasAttribute('data-listeners-attached')) {
                    return; // Skip if already set up
                }
                
                // Mark this audio as having listeners attached
                audio.setAttribute('data-listeners-attached', 'true');
                
                // Add new listeners
                audio.addEventListener('ended', function() {
                    console.log(`🏁 Audio ${index} ended, auto-play enabled: ${autoPlayEnabled}, queue length: ${playQueue.length}`);
                    console.log(`🔍 Audio state: paused=${this.paused}, ended=${this.ended}, currentTime=${this.currentTime}`);
                    
                    currentPlayingIndex = -1;
                    isPlayingFromQueue = false;
                    
                    if (autoPlayEnabled) {
                        // Continue with auto-play queue
                        console.log(`⏭️ Audio ended, processing next in queue after delay`);
                        setTimeout(() => {
                            console.log(`🚀 Now actually processing auto-play queue`);
                            processAutoPlayQueue();
                        }, 800);  // Longer delay to ensure audio state is fully updated
                    } else {
                        console.log(`🔇 Auto-play disabled, not continuing`);
                    }
                });
                
                audio.addEventListener('play', function() {
                    console.log(`🎵 Audio ${index} started playing`);
                    // Pause other audio elements
                    const allAudioElements = document.querySelectorAll('#audio-list audio');
                    allAudioElements.forEach((otherAudio, otherIndex) => {
                        if (otherIndex !== index && !otherAudio.paused) {
                            otherAudio.pause();
                        }
                    });
                    currentPlayingIndex = index;
                    
                    // Update visual highlighting
                    updateAudioHighlighting(index);
                    
                    // User interaction detected - enable auto-play capability
                    if (!window.userHasInteracted) {
                        window.userHasInteracted = true;
                        console.log(`👆 User interaction detected, auto-play capability enabled`);
                    }
                });
                
                audio.addEventListener('pause', function() {
                    // Remove highlighting when paused
                    updateAudioHighlighting(-1);
                });
            });
        }
        
        function playAudio(index) {
            const audioElements = document.querySelectorAll('#audio-list audio');
            console.log(`🎯 Trying to play audio ${index}, found ${audioElements.length} audio elements`);
            
            if (index >= 0 && index < audioElements.length) {
                // Pause all other audio and reset their state
                console.log(`⏸️ Pausing all other audio elements`);
                audioElements.forEach((audio, audioIndex) => {
                    if (audioIndex !== index) {
                        audio.pause();
                        audio.currentTime = 0;
                        console.log(`🔇 Reset audio ${audioIndex}: paused=${audio.paused}, currentTime=${audio.currentTime}`);
                    }
                });
                
                // Play selected audio
                const targetAudio = audioElements[index];
                targetAudio.currentTime = 0;
                
                console.log(`🎵 About to play audio ${index}, src: ${targetAudio.src}`);
                
                // Use promise-based play with error handling
                const playPromise = targetAudio.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        console.log(`✅ Successfully started playing audio ${index}`);
                        currentPlayingIndex = index;
                        isPlayingFromQueue = autoPlayEnabled; // Update flag
                    }).catch(error => {
                        console.error(`❌ Error playing audio ${index}:`, error);
                        // Handle auto-play policy restrictions
                        if (error.name === 'NotAllowedError') {
                            console.log('🚫 Auto-play blocked by browser policy');
                            // If auto-play is blocked, disable auto-play mode
                            if (autoPlayEnabled) {
                                addLog('🚫 Auto-play disabled due to browser policy', 'warning');
                                autoPlayEnabled = false;
                                const btn = document.getElementById('auto-play-btn');
                                btn.innerHTML = '<i class="fas fa-play"></i> Auto-Play OFF';
                                btn.className = 'btn btn-outline-light btn-sm';
                                playQueue = [];
                                isPlayingFromQueue = false;
                            }
                        } else if (autoPlayEnabled && isPlayingFromQueue) {
                            // If there's an error during auto-play, continue with next audio
                            console.log('⏭️ Continuing to next audio in queue after error');
                            isPlayingFromQueue = false;
                            setTimeout(() => processAutoPlayQueue(), 1000);
                        }
                    });
                } else {
                    console.log(`📱 Browser doesn't support promises for play(), setting currentPlayingIndex anyway`);
                    currentPlayingIndex = index;
                }
            } else {
                console.warn(`⚠️ Invalid audio index: ${index}, available: 0-${audioElements.length - 1}`);
                // If this was from auto-play queue, continue with next audio
                if (autoPlayEnabled && isPlayingFromQueue) {
                    console.log('⏭️ Continuing to next audio in queue after invalid index');
                    isPlayingFromQueue = false;
                    setTimeout(() => processAutoPlayQueue(), 500);
                }
            }
        }
        
        // Add debouncing for auto-play toggle
        let toggleDebounceTimer = null;
        
        function toggleAutoPlay() {
            // Prevent rapid consecutive calls
            if (toggleDebounceTimer) {
                console.log('Auto-play toggle ignored due to debouncing');
                return;
            }
            
            toggleDebounceTimer = setTimeout(() => {
                toggleDebounceTimer = null;
            }, 300); // 300ms debounce
            
            autoPlayEnabled = !autoPlayEnabled;
            const btn = document.getElementById('auto-play-btn');
            
            console.log(`🎵 Auto-play toggled: ${autoPlayEnabled}`);
            
            if (autoPlayEnabled) {
                btn.innerHTML = '<i class="fas fa-pause"></i> Auto-Play ON';
                btn.className = 'btn btn-success btn-sm';
                addLog('🎵 Auto-play enabled', 'info');
                
                // Check for user interaction requirement
                if (!window.userHasInteracted) {
                    addLog('💡 提示：首次使用自动播放需要先手动播放一个音频', 'info');
                }
                
                // Add all existing unplayed audio files to queue
                const audioElements = document.querySelectorAll('#audio-list audio');
                playQueue = []; // Clear existing queue
                
                console.log(`📱 Found ${audioElements.length} audio elements`);
                
                // Check if any audio is currently playing
                const currentlyPlaying = document.querySelector('#audio-list audio:not([paused])');
                let startIndex = 0;
                
                if (currentlyPlaying) {
                    // If something is playing, start from the next audio
                    const playingIndex = parseInt(currentlyPlaying.getAttribute('data-index'));
                    startIndex = playingIndex + 1;
                    console.log(`🎧 Audio ${playingIndex} is currently playing, will start auto-play from ${startIndex}`);
                    // Mark user interaction since audio is playing
                    window.userHasInteracted = true;
                } else {
                    console.log(`🔇 No audio currently playing, will start from index 0`);
                }
                
                // Add remaining audio files to queue
                for (let i = startIndex; i < audioElements.length; i++) {
                    playQueue.push(i);
                    console.log(`➕ Added audio ${i} to auto-play queue`);
                }
                
                console.log(`🎯 Auto-play queue now has ${playQueue.length} items: [${playQueue.join(', ')}]`);
                
                // Start processing queue if nothing is currently playing
                if (!currentlyPlaying && !isPlayingFromQueue && playQueue.length > 0) {
                    console.log(`🚀 Starting auto-play queue processing`);
                    // For better browser compatibility, start with a small delay and user interaction
                    setTimeout(() => {
                        console.log(`🎬 Attempting to start auto-play...`);
                        processAutoPlayQueue();
                    }, 500);
                } else if (currentlyPlaying) {
                    console.log(`⏳ Will start auto-play when current audio finishes`);
                } else if (playQueue.length === 0) {
                    console.log(`❌ No audio files in queue to auto-play`);
                }
            } else {
                btn.innerHTML = '<i class="fas fa-play"></i> Auto-Play OFF';
                btn.className = 'btn btn-outline-light btn-sm';
                addLog('🔇 Auto-play disabled', 'info');
                
                // Clear the queue and stop auto-play
                playQueue = [];
                isPlayingFromQueue = false;
                console.log(`🛑 Auto-play disabled, queue cleared`);
            }
        }
    </script>
</body>
</html> 